#version 120

//Adjustable variables. Tune these for performance
#define MAX_RAY_LENGTH          35.0
#define MAX_DEPTH_DIFFERENCE    0.1 //How much of a step between the hit pixel and anything else is allowed?
#define RAY_STEP_LENGTH         0.75
#define MAX_REFLECTIVITY        1.0 //As this value approaches 1, so do all reflections
#define RAY_DEPTH_BIAS          0.05   //Serves the same purpose as a shadow bias
#define RAY_GROWTH              1.2    //Make this number smaller to get more accurate reflections at the cost of performance
                                        //numbers less than 1 are not recommended as they will cause ray steps to grow
                                        //shorter and shorter until you're barely making any progress
#define NUM_RAYS                1   //The best setting in the whole shader pack. If you increase this value,
                                    //more and more rays will be sent per pixel, resulting in better and better
                                    //reflections. If you computer can handle 4 (or even 16!) I highly recommend it.

uniform sampler2D gcolor;
uniform sampler2D gdepthtex;
uniform sampler2D gdepth;
uniform sampler2D gnormal;
uniform sampler2D composite;
uniform sampler2D gaux1;
uniform sampler2D gaux2;
uniform sampler2D gaux3;

uniform sampler2D noisetex;

uniform vec3 cameraPosition;
uniform mat4 gbufferModelView;
uniform mat4 gbufferProjection;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferProjectionInverse;

uniform float near;
uniform float far;
uniform float viewWidth;
uniform float viewHeight;

uniform vec3 skyColor;

varying vec2 coord;

struct Pixel1 {
    vec3 position;
    vec3 color;
    vec3 normal;
    float emission;
    float metalness;
    float smoothness;
    float R0;
    
    float waterDepth;
    float terrainDepth;
};

float rayLen;

///////////////////////////////////////////////////////////////////////////////
//                              Helper Functions                             //
///////////////////////////////////////////////////////////////////////////////
//Credit to Sonic Ether for depth, normal, and positions

float getDepth(  vec2 coord ) {	
    return texture2D( gdepthtex, coord ).r;
}

float getDepthLinear( vec2 coord ) {
    return 2.0 * near * far / (far + near - (2.0 * texture2D( gdepthtex, coord ).r - 1.0) * (far - near));
}

vec4 getScreenSpacePosition() {	
	float depth = getDepth( coord );
	vec4 fragposition = gbufferProjectionInverse * vec4( coord.s * 2.0 - 1.0, coord.t * 2.0 - 1.0, 2.0 * depth - 1.0, 1.0 );
		 fragposition /= fragposition.w;
	return fragposition;
}

vec4 getWorldSpacePosition() {
	vec4 pos = getScreenSpacePosition();
	pos = gbufferModelViewInverse * pos;
	pos.xyz += cameraPosition.xyz;
	return pos;
}

vec3 getCameraSpacePosition( vec2 uv ) {	
	float depth = getDepth( uv );
	vec4 fragposition = gbufferProjectionInverse * vec4( uv.s * 2.0 - 1.0, uv.t * 2.0 - 1.0, 2.0 * depth - 1.0, 1.0 );
		 fragposition /= fragposition.w;
	return fragposition.xyz;
}

vec3 cameraToWorldSpace( vec3 cameraPos ) {
    vec4 pos = vec4( cameraPos, 1 );
    pos = gbufferModelViewInverse * pos;
    pos.xyz /= pos.w;
    return pos.xyz;
}

vec2 getCoordFromCameraSpace( in vec3 position ) {
    vec4 viewSpacePosition = gbufferProjection * vec4( position, 1 );
    vec2 ndcSpacePosition = viewSpacePosition.xy / viewSpacePosition.w;
    return ndcSpacePosition * 0.5 + 0.5;
}

vec3 getColor() {
    return pow( texture2D( gaux1, coord ).rgb, vec3( 2.2 ) );
}

float getEmission() {
    return texture2D( composite, coord ).b;
}

float getWaterDepth() {
    return texture2D( gnormal, coord ).a;
}

float getSmoothness() {
    return texture2D( gdepth, coord ).g;
}

float getR0() {
    return texture2D( gdepth, coord ).r;
}

vec3 getNormal() {
    return normalize( texture2D( gnormal, coord ).xyz * 2.0 - 1.0 );
}

float getMetalness() {
    return texture2D( gdepth, coord ).b;
}

float getTerrainDepth() {
    return texture2D( gdepth, coord ).b;
}

///////////////////////////////////////////////////////////////////////////////
//                              Main Functions                               //
///////////////////////////////////////////////////////////////////////////////

void fillPixelStruct( inout Pixel1 pixel ) {
    pixel.position      = getCameraSpacePosition( coord );
    pixel.normal        = getNormal();
    pixel.color         = getColor();
    pixel.metalness     = getMetalness();
    pixel.smoothness    = getSmoothness();
    pixel.R0            = getR0();
    pixel.emission      = getEmission();
    pixel.waterDepth    = getWaterDepth();
    pixel.terrainDepth  = getTerrainDepth();
}

//Determines the UV coordinate where the ray hits
//If the returned value is not in the range [0, 1] then nothing was hit.
//NOTHING!
vec2 castRay( in vec3 origin, in vec3 direction ) {
    vec3 curPos = origin;
    vec2 curCoord = getCoordFromCameraSpace( curPos );
    direction = normalize( direction ) * RAY_STEP_LENGTH;
    bool forward = true;

    //The basic idea here is the the ray goes forward until it's behind something,
    //then slowly moves forward until it's in front of something.
    for( int i = 0; i < MAX_RAY_LENGTH * (1 / RAY_STEP_LENGTH); i++ ) {
        curPos += direction;
        curCoord = getCoordFromCameraSpace( curPos );
        if( curCoord.x < 0 || curCoord.x > 1 || curCoord.y < 0 || curCoord.y > 1 ) {
            //If we're here, the ray has gone off-screen so we can't reflect anything
            return vec2( -1 );
        }
        if( length( curPos - origin ) > MAX_RAY_LENGTH ) {
            return vec2( -1 );
        }
        float worldDepth = getCameraSpacePosition( curCoord ).z;
        float rayDepth = curPos.z;
        float depthDiff = (worldDepth - rayDepth);
        float maxDepthDiff = length( direction ) + RAY_DEPTH_BIAS;
        if( forward ) {
            if( depthDiff > 0 && depthDiff < maxDepthDiff ) {
                //return curCoord;
                direction = -1 * normalize( direction ) * 0.15;
                forward = false;
            } 
        } else {
            depthDiff *= -1;
            if( depthDiff > 0 && depthDiff < maxDepthDiff ) {
                return curCoord;
            }
        }
        direction *= RAY_GROWTH;
    }
    //If we're here, we couldn't find anything to reflect within the alloted number of steps
    return vec2( -1 ); 
}

vec3 doLightBounce( in Pixel1 pixel ) {
    //Find where the ray hits
    //get the blur at that point
    //mix with the color 
    vec3 rayStart = pixel.position;
    vec2 noiseCoord = vec2( coord.s * viewWidth / 64.0, coord.t * viewHeight / 64.0 );
    vec3 retColor = vec3( 0 );
    vec3 noiseSample = vec3( 0 );
    vec3 reflectDir = vec3( 0 );
    vec3 rayDir = vec3( 0 );
    vec2 hitUV = vec2( 0 );
    
    //trace the number of rays defined previously
    for( int i = 0; i < NUM_RAYS; i++ ) {
        noiseSample = texture2D( noisetex, noiseCoord * (i + 1) ).rgb * 2.0 - 1.0;
        reflectDir = normalize( noiseSample * (1.0 - pixel.smoothness) * 0.25 + pixel.normal );
        reflectDir *= sign( dot( pixel.normal, reflectDir ) );
        rayDir = reflect( normalize( rayStart ), reflectDir );
    
        hitUV = castRay( rayStart, rayDir );
        if( hitUV.s > 0.0 && hitUV.s < 1.0 && hitUV.t > 0.0 && hitUV.t < 1.0 ) {
            retColor += vec3( texture2D( composite, hitUV.st ).rgb * MAX_REFLECTIVITY );
        } /*else {
            float water = step( 0.0, pixel.waterDepth );
            retColor += skyColor * water + pixel.color * (1.0 - water);
        }*/
    }
    
    return retColor / NUM_RAYS;
}

float luma( vec3 color ) {
    return dot( color, vec3( 0.2126, 0.7152, 0.0722 ) );
}

void main() {
    Pixel1 pixel;
    fillPixelStruct( pixel );
    vec3 hitColor = pixel.color;
#if NUM_RAYS > 0
    if( pixel.emission < 0.5 ) {
        hitColor = doLightBounce( pixel );
        
        vec3 viewVector = normalize( getCameraSpacePosition( coord ) );

        float vdoth = clamp( dot( -viewVector, pixel.normal ), 0, 1 );

        float smoothness = pixel.smoothness;
        float metalness = pixel.metalness;
        float waterness = step( 0.0, pixel.waterDepth );
    
        vec3 reflectedColor = doLightBounce( pixel ).rgb; 

        smoothness = pow( smoothness, 4 );
        vec3 sColor = (pixel.color * metalness + vec3( pixel.R0 ) * (1.0 - metalness));
            //* (1.1 - waterness);
        vec3 fresnel = sColor + (vec3( 1.0 ) - sColor) * pow( 1.0 - vdoth, 5 );

        reflectedColor *= fresnel;

        // Calculate water (and glass, we're inclusive here) refractions
        // There is at least one glaring problem with this algorithm. It assumes
        // that the view vector, the refracted light ray, and the xz plane all
        // form a right triangle, which is not the case. However, on a normalmapped
        // surface, this issue should be all but impossible to discern. Plus, it's
        // significantly faster than actually tracing the ray. I spend enough time
        // tracing rays already
        float wDepth = pixel.waterDepth;
        vec3 refractedColor = pixel.color;
        if( wDepth < 0 ) {
            float tDepth = pixel.terrainDepth;
            float depthDiff = tDepth - wDepth;
            // Assume that glass and water have the same refractive index.
            // In the future, I may find a way to pass along the IOR, but not today!
            vec3 resultant = refract( viewVector, pixel.normal, 1.0 / 1.33 );
        
            float cosTheta = dot( viewVector, resultant );
            float distToPixel = tDepth * sqrt( 1.0 - cosTheta * cosTheta ) / cosTheta;
            // So now we need to go distToPixel units in the direction
            // We know the normal in view space, so we can just grab the x and y
            // components
            // A scaling factor will probably be needed. Will find later.
            vec2 refractOffset = viewVector.xy * distToPixel;
            refractedColor = texture2D( composite, coord + refractOffset ).rgb;
            // In a perfect world, I'd multiply refractedColor by the
            // material's color. Problem is, this isn't a perfect world
            hitColor = vec3( -tDepth );
        }
        //hitColor = vec3( -wDepth );

        hitColor = (vec3( 1.0 ) - fresnel) * refractedColor * (1.0 - metalness) + reflectedColor;
    }
#endif
    
    gl_FragData[0] = texture2D( gcolor, coord );
    gl_FragData[1] = texture2D( gdepth, coord );
    gl_FragData[2] = texture2D( gnormal, coord );
    gl_FragData[3] = texture2D( composite, coord );
    gl_FragData[4] = texture2D( gaux1, coord );

    gl_FragData[5] = vec4( hitColor, 1 );
    gl_FragData[5] = texture2D( gaux2, coord );
    
    gl_FragData[6] = texture2D( gaux3, coord );
}
